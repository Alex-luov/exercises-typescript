---

name: Ковариантность и контрвариантность
theory: |

  В процессе...

  Вернемся к примеру с `ComparatorCallback` из урока про иерархию типов:

  ```typescript
  type ComparatorCallback = (item1: number, item2: number, index: number) => -1 | 0 | 1
  declare function sort(arr: Array<number>, callback: ComparatorCallback): Array<number>

  const arr = [1, 2, 3];
  const comparator = (item1: number, item2: number) => Math.sign(item1 - item2);
  //    ^? const comparator = (item1: number, item2: number) => number;

  sort(arr, comparator) // Error: Type 'number' is not assignable to type '0 | 1 | -1'.
  //        ~~~~~~~~~~
  ```

  Доносим идею о компромисе между гибкостью и типобезопаностью
  Присваиваемость функций

  В TypeScript каждый сложный тип является ковариантным в своих членах — объектах, классах, массивах и возвращаемых типах функций, за одним исключением: типы параметров функций контрвариантны.

  ```typescript
  type Formatter = (val: string) => string;

  const formatToConcrete: Formatter = (_val: string): 'test' => 'test';
  const formatToNumber: Formatter = (val: string): string | number => +val;
  // Type '(val: string) => string | number' is not assignable to type 'Formatter'.
  ```

instructions: |

tips:
  - |
    [Статья Теория программирования: Вариантность](https://habr.com/ru/post/477448/)

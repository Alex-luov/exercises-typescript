---

name: Иерархия типов
theory: |

  Давайте рассмотрим пример ошибки `Type X is not assignable to type Y` в функции, для сортировки элементов. Будем считать, что у нас где-то уже написана функция `sort`. И чтобы описать только ее типы воспользуемся ключевым словом `declare`:

  ```typescript
  type ComparatorCallback = (item1: number, item2: number, index: number) => -1 | 0 | 1
  declare function sort(arr: Array<number>, callback: ComparatorCallback): Array<number>

  const arr = [1, 2, 3];
  const comparator = (item1: number, item2: number) => Math.sign(item1 - item2);

  sort(arr, comparator) // Error: Type 'number' is not assignable to type '0 | 1 | -1'.
  ```

  Проверка типов выдала ошибку, что объединение литеральных типов `0 | 1 | -1` не совместимо с типом `number`. И на первый взгляд кажется, что система типов ошибается и пора использовать `any`, но, если мы подумаем о литеральных числовых типах как о подмножествах `number`, все становится логично.

  Здесь как раз более отчетливо просматривается связь типов с теорией множеств. Множество `A` является подмножеством `B`, если любой элемент, принадлежащий `A`, также принадлежит `B`. Тем самым мы получаем связи между типами, которые выстраиваются в иерархию типов. И это помогает нам понять возможно ли присвоить переменную одного типа переменной другого типа.

  В уроке про литеральные типы мы говорили, что они существуют для четырех типов данных: `boolean`, `string`, `number`, `BigInt`. Таким образом любой литеральный тип мы можем присвоить переменной соответствующего типа:

  ```typescript
  let num: number = 1;
  const two: 2 = 2;
  const notTrue: false = false;

  num = two;
  num = notTrue; // Type 'boolean' is not assignable to type 'number'.
  ```

  Здесь `2` используется как литеральный тип, который представляет из себя множество из одного элемента – единицы.

  Анализатор успешно пропустил присваивание литерального типа числа к `number`, но литеральный `boolean` тип мы уже не смогли присвоить. Для того, чтобы решить эту проблему мы могли бы использовать объединение типов `number | boolean`, но если мы не уверенны, что может быть присвоено, то нам пришлось бы делать объединение с потенциально огромным числом типов.

  Тут нам приходит на помощь тип `unknown`, представляющий собой надмножество всех доступных типов, который позволяет присвоить переменной значение произвольного типа:

  ```typescript
  let unknownValue: unknown = 1;
  const two: 2 = 2;
  const notTrue: false = false;

  unknownValue = two;
  unknownValue = notTrue; // OK
  ```

  Куда более редкий случай на практике, когда нам нужно быть уверенными, что переменной не будет присвоено никакого значения, позволяет реализовать тип `never`:

  ```typescript
  let neverValue: never;
  const two: 2 = 2;

  neverValue = two; // Type 'number' is not assignable to type 'never'
  ```

  Из текущих знаний мы можем составить следующую картинку множеств типов TypeScript:

  ![NumberOrString](https://raw.githubusercontent.com/hexlet-basics/exercises-typescript/main/modules/25-types/50-type-hierarcy/assets/hierarcy_circle.png)

  В множество `number` также входят все объединения литеральных типов чисел, а в множество `string` - литеральных строк:

  ```typescript
  type NumberUnion = -2 | -1 | 1 | 2

  const one: NumberUnion = 1;
  const num: number = one;

  type StringUnion = 'a' | 'b' | 'c' | 'd'

  const aChar: StringUnion = 'a';
  const str: string = aChar;
  ```

  Такое подмножество типов называют подтипом, а само множество супертипом.

  Взаимосвязи подтипов и супертипов (базовых) являются ключевой концепцией любого статически типизированного языка и образуют иерархию типов. Это становится особо важно, когда мы хотим привести один тип к другому.

  Рассмотрим различные варианты приведения типов:

  ```typescript
  let num = 1; // Неявное восходящее приведение
  const one: number = 1; // Явное восходящее приведение

  const two = num as 2; // Явное нисходящее приведение

  const three = 3 as const; // Приведение к литеральному типу - нисходящее
  ```

  Каждый раз, когда мы присваиваем значение в переменную или передаем аргументы в функцию TypeScript пытается сделать восходящее приведение - от подтипа к базовому. Также мы можем явно задать восходящее приведение. Мы уже часто пользовались этой возможностью, чтобы проверить, возможно ли привести один тип к другому или указать явно, переменную какого типа мы ожидаем.

  В противовес этому приведение базового типа к подтипу делается явно с помощью `as`. При таком поведении TypeScript принимает наше решение привести типы за истину и в некоторых случаях это может привести к ошибки. Поэтому нисходящее приведение считается не безопасным и маркером, что к этому коду нужно пристально присмотреться.

instructions: |

  Реализуйте функцию `getUserFriends()`, которая принимает JSON с массивом пользователей и с массивом id друзей, и возвращает список друзей пользователя по id. Друзья каждого пользователя хранятся в поле `friends`.

  Если пользователь с указанным id не найден, то функция должна вернуть пустой массив.

  ```typescript
  const userJson = JSON.stringify({
    users: [
      { id: 1, name: 'John', age: 20 },
      { id: 2, name: 'Mary', age: 21 },
    ],
    friends: [
      [1, 2],
    ],
  });

  getUserFriends(userJson, 1); // [{ id: 2, name: 'Mary', age: 21 }]
  getUserFriends(userJson, 2); // [{ id: 1, name: 'John', age: 20 }]
  getUserFriends(userJson, 3); // []
  ```

tips:
  - |
    [Как устроена система типов в TypeScript](https://ru.hexlet.io/blog/posts/sistema-tipov-v-typescript)

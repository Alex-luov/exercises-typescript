---
name: Иерархия типов
theory: |

  В этом уроке мы разберем связь между типами, которая выстраивается в иерархию.
  
  ## Типы как подмножества
  
  Рассмотрим пример ошибки `Type X is not assignable to type Y` в функции для сортировки элементов. Допустим, у нас уже написана функция `sort`. И чтобы описать только ее типы, воспользуемся ключевым словом `declare`:

  ```typescript
  type ComparatorCallback = (item1: number, item2: number, index: number) => -1 | 0 | 1
  declare function sort(arr: Array<number>, callback: ComparatorCallback): Array<number>

  const arr = [1, 2, 3];
  const comparator = (item1: number, item2: number) => Math.sign(item1 - item2);

  sort(arr, comparator) // Error: Type 'number' is not assignable to type '0 | 1 | -1'.
  ```

  Проверка типов выдала ошибку: объединение литеральных типов `0 | 1 | -1` не совместимо с типом `number`. Можно подумать, что система типов ошибается, и стоит использовать `any`. Но если мы подумаем о литеральных числовых типах как о подмножествах `number`, все становится логично.

  Здесь отчетливо просматривается связь типов с теорией множеств. Множество `A` является подмножеством `B`, если любой элемент, который принадлежит `A`, также принадлежит `B`. Так мы получаем связи между типами, которые выстраиваются в иерархию типов. Это помогает понять, возможно ли присвоить переменную одного типа переменной другого типа.

  ## Литеральные типы

  Напомним, что литеральные типы существуют для четырех типов данных: `boolean`, `string`, `number`, `BigInt`. В итоге любой литеральный тип можно присвоить переменной соответствующего типа:

  ```typescript
  let num: number = 1;
  const two: 2 = 2;
  const notTrue: false = false;

  num = two;
  num = notTrue; // Type 'boolean' is not assignable to type 'number'.
  ```

  Здесь `2` используется как литеральный тип, который представляет из себя множество из одного элемента — двойки.

  Анализатор успешно пропустил присваивание литерального типа числа к `number`, но литеральный `boolean` тип мы уже не смогли присвоить. Чтобы решить эту проблему, можно использовать объединение типов `number | boolean`. Но если мы не уверены, что может быть присвоено, нам пришлось бы делать объединение с потенциально огромным числом типов.
  
  В этом случае нам на помощь приходит тип `unknown`.

  ## `unknown`

  Тип `unknown` — это надмножество всех доступных типов, который позволяет присвоить переменной значение произвольного типа:

  ```typescript
  let unknownValue: unknown = 1;
  const two: 2 = 2;
  const notTrue: false = false;

  unknownValue = two;
  unknownValue = notTrue; // OK
  ```
  
  <!-- TODO - автору: не хватает описания кода - на что обратить внимание, или что тут сделали -->
  
  Далее разберем случай, когда нам не нужно присваивать переменной никакого значения.

  ## `never`
  
  Иногда на практике нужно быть уверенным, что переменной не будет присвоено никакого значения. Это можно реализовать с помощью типа `never`:

  ```typescript
  let neverValue: never;
  const two: 2 = 2;

  neverValue = two; // Type 'number' is not assignable to type 'never'
  ```
  
  <!-- TODO - автору: не хватает описания кода - на что обратить внимание, или что тут сделали -->
  
  ## Множества типов

  Из текущих знаний мы можем составить следующую картинку множеств типов TypeScript:

  ![NumberOrString](https://raw.githubusercontent.com/hexlet-basics/exercises-typescript/main/modules/25-types/50-type-hierarcy/assets/hierarcy_circle.png)

  В множество `number` также входят все объединения литеральных типов чисел, а в множество `string` — литеральных строк:

  ```typescript
  type NumberUnion = -2 | -1 | 1 | 2

  const one: NumberUnion = 1;
  const num: number = one;

  type StringUnion = 'a' | 'b' | 'c' | 'd'

  const aChar: StringUnion = 'a';
  const str: string = aChar;
  ```

  Такое подмножество типов называют подтипом, а само множество супертипом.

  Взаимосвязи подтипов и супертипов — ключевая концепция любого статически типизированного языка. Они образуют иерархию типов. Это становится особо важно, когда мы хотим привести один тип к другому.

  ## Приведение типов

  Рассмотрим различные варианты приведения типов:

  ```typescript
  let num = 1; // Неявное восходящее приведение
  const one: number = 1; // Явное восходящее приведение

  const two = num as 2; // Явное нисходящее приведение

  const three = 3 as const; // Приведение к литеральному типу — нисходящее
  ```

  Когда мы присваиваем значение в переменную или передаем аргументы в функцию, TypeScript пытается сделать восходящее приведение — от подтипа к базовому. Также можно явно задать восходящее приведение. Мы уже пользовались этой возможностью, чтобы проверить, возможно ли привести один тип к другому или указать явно, переменную какого типа мы ожидаем.

  Приведение базового типа к подтипу делается явно с помощью `as`. При таком поведении TypeScript принимает приведение типов за истину. В некоторых случаях это может привести к ошибке. Поэтому нисходящее приведение считается небезопасным. К такому коду нужно пристально присмотреться.

instructions: |

  Реализуйте функцию `getUserFriends()`, которая принимает JSON с массивом пользователей и с массивом id друзей и возвращает список друзей пользователя по id. Друзья каждого пользователя хранятся в поле `friends`.

  Если пользователь с указанным id не найден, то функция должна вернуть пустой массив.

  ```typescript
  const userJson = JSON.stringify({
    users: [
      { id: 1, name: 'John', age: 20 },
      { id: 2, name: 'Mary', age: 21 },
    ],
    friends: [
      [1, 2],
    ],
  });

  getUserFriends(userJson, 1); // [{ id: 2, name: 'Mary', age: 21 }]
  getUserFriends(userJson, 2); // [{ id: 1, name: 'John', age: 20 }]
  getUserFriends(userJson, 3); // []
  ```

tips:
  - |
    [Как устроена система типов в TypeScript](https://ru.hexlet.io/blog/posts/sistema-tipov-v-typescript)
  - |
    [Type Assertion](https://basarat.gitbook.io/typescript/type-system/type-assertion)

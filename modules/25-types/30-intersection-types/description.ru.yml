---

name: Пересечение (Intersections Types)
theory: |

  Вместе с объединением важной операцией в теории множеств является пересечение. Для разработчиков, привыкших к динамике JavaScript, эта операция может показаться менее значимой, но без нее не обойтись, например при описании типа слияния объектов.

  Пересечение указывается с помощью символа `&`, по обе стороны от которого располагаются типы. Давайте определим тип объекта со статусом заказа, а затем более строгий тип с точной ценой:

  ```typescript
  type Order = {
    status: 'Created',
  }

  type OneHundredOrder = Order & {
    cost: 100
  }

  const myOrder: OneHundredOrder = {
    status: 'Created',
    cost: 100
  }
  ```

  Из пересечения объектных типов с полями `status` **И** `cost`, мы получили тип `OneHundredOrder`, который содержит оба этих поля.

  Тип – это множество значений. Когда мы задаем пересечение типов, мы получаем новый тип, который содержит значения подходящие под ограничения обоих типов.

  ![NumberOrString](https://raw.githubusercontent.com/hexlet-basics/exercises-typescript/main/modules/25-types/30-intersection-types/assets/one_hundred_order.png)

  Если мы объявим переменную `const StringAndNumber: string & number`, то ей нужно будет присвоить такое значение, которое одновременно принадлежит множествам `string` и `number`, то есть является одновременно и строкой, и числом. Такого значения не существует, поэтому `StringAndNumber` будет иметь тип `never`. `never` соответствует пустому множеству, то есть тип не имеющий ни одного значения.

instructions: |
  Реализуйте функцию `reverseDoubleLinkedList`, которая принимает двусвязный список и разворачивает его.

  ```typescript
  const list: DoubleLinkedList = {
    value: 1,
    next: null,
    prev: null,
  };
  const list2: DoubleLinkedList = {
    value: 2,
    next: null,
    prev: list
  }
  list.next = list2

  reverseDoubleLinkedList(list);

  console.log(list.prev === list2) // true
  console.log(list2.next === list) // true
  ```

  Для того, чтобы получить тип `DoubleLinkedList` удобно будет расширить его через объединение с `SinglyLinkedList`.

---

name: Литералы (Literal Types)
theory: |

  В программировании встречаются ситуации, когда мы работаем с ограниченным набором значений какого-то типа, например c определенными строками: сюда могут входить справочные данные, статусы и так далее. Как мог бы выглядеть статус заказа:

  ```
  Created
  Paid
  Shipped
  Delivered
  ```

  Код, который работает с этими данными, будет сохранять их в базу данных, отправлять и получать по сети, выполнять проверки того, в каком статусе находится заказ, и так далее.

  Какого типа будут переменные, содержащие такие данные? Если использовать общий тип, например `string`, то появляется множество проблем:

  * Компилятор не увидит опечаток
  * Компилятор не увидит использование недопустимых статусов
  * Мы не сможем увидеть, какие статусы у нас вообще есть
  * Не сработает автокомплит в редакторе

  Для решения этой задачи TypeScript поддерживает литеральный тип. Они доступны только для следующих типов: `string`, `boolean`, `number` и `BigInt`.

  ```typescript
  type Hexlet = 'hexlet';
  type One = 1;
  type False = false;
  type BigN = 100n;
  ```

  С точки зрения теории множеств, такой тип представляет собой множество, состоящее из одного элемента, а для системы типов это ограничение, что переменной не может быть присвоено ничего, кроме указанного значения:

  ```typescript
  type TestValue = 'test';
  let test: TestValue = 'test';

  test = 'string'; // Error: Type '"string"' is not assignable to type '"test"'.
  ```

  ## Объединение литеральных типов

  Используя объединение типов, мы можем получить тип, который принимает только нужные нам значения:

  ```typescript
  type OrderStatus = 'Created' | 'Paid' | 'Shipped' | 'Delivered';
  ```

  Также литеральные типы могут комбинироваться с любыми другими типами, так мы можем получить ограничение, под которое попадают все числа и `false`:

  ```typescript
  type NumberFalse = number | false;
  ```

  ## Строковые перечисления (String enums)

  Проблема, описанная в этом уроке, в большинстве языков реализуется через перечисления, которые также добавлены в TypeScript:

  ```typescript
  enum OrderStatus {
    Created = 'Created',
    Paid = 'Paid',
    Shipped = 'Shipped',
    Delivered = 'Delivered',
  }
  ```

  Но в TypeScript с перечислениями не все так радужно. TypeScript, как мы помним, это надстройка над JavaScript, добавляющая типы, но не изменяющая сам язык. В случае с Enum это не так. Перечисления — это конструкция языка, которая остается существовать в коде после трансляции кода в JavaScript.

  По этой причине некоторые разработчики предпочитают использовать вместо них Union Types, которые позволяют сделать практически то же самое с помощью строковых литералов.

  Несмотря на это, рекомендуется использовать Enum в прикладном коде, так как это дает дополнительные гарантии надежности. А  коде библиотек использовать Union Types, так как это более гибко и дает дополнительные возможности.

  ## Литеральные объекты

  При конфигурации библиотеками нам встречаются случаи, когда от нас ожидают одну из строк. Например, дают выбор из нескольких баз данных:

  ```typescript
  const dataSourceConfig = {
    type: 'postgre', // может также быть mysql
    host: 'localhost',
    port: 5432,
  };

  const AppDataSource = new DataSource(dataSourceConfig)
  ```

  Для описания таких объектов используется тип объектных литералов, где поля инициализируются одним литеральным типом или их пересечением:

  ```typescript
  type DataSourceOption = {
    type: 'postgre' | 'mysql';
    host: string;
    port: number;
  }
  ```

  Это дает авторам библиотек дополнительный инструмент документации, а разработчикам крутой автокомплит и уберегает от ошибок в передаваемых аргументах.

  ## Приведение к литеральному типу

  В случае с объектами конфигурации часто мы не хотим, чтобы их меняли извне, и ожидаем конкретных значений внутри, здесь нам на помощь приходит приведение типа к литеральному через Type Assertion `as const`:

  ```typescript
  const ormConfig = {
    type: 'mysql',
    host: 'localhost',
    port: 5432,
  } as const;
  ```

  На выходе мы получаем тип с неизменяемыми (`readonly`) полями и литеральными типами в значении. Такая техника также применима к массивам, превращая их в кортежи - массивы фиксированной длины, также защищенные от изменений.

instructions: |

  Реализуйте функцию `makeTurn()`, принимающую строку `left` или `right` и перемещающую черепашку вперед-назад по одномерной карте длиной пять. Если ход невозможен, должно выброситься исключение.

  ```typescript
  const { makeTurn, state } = startGame();
  console.log(state); // ['turtle', null, null, null, null]

  makeTurn('left') // ERROR

  makeTurn('right');
  makeTurn('right');
  console.log(state); // [null, null, 'turtle', null, null]
  ```

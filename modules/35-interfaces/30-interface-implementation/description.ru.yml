---

name: Реализация интерфейсов классами
theory: |

  В TypeScript классы могут тесно взаимодействовать с интерфейсами. В прошлом уроке мы увидели как интерфейсы могут расширять другие интерфейсы и комбинировать их. Аналогичным образом классы могут быть расширены интерфейсами:

  ```typescript
  interface IBeep {
    sayBeep: () => string;
  }

  interface IBoop {
    sayBoop: () => string;
  }

  class Robo implements IBeep, IBoop {
    sayBeep = () => 'beep';
    sayBoop = () => 'boop';
  }

  const R2D2 = new Robo();
  R2D2.sayBeep(); // 'beep'
  ```

  Мы можем создавать классы на основе интерфейсов точно также как мы создаем интерфейсы на основе интерфейсов. Но есть и отличия - если мы создаем интерфейс или тип и потом транспилируем TypeScript в JavaScript, то в коде не останется образца этого интефейса. В то же время, при создании класса его образец всегда переносится и в JavaScript при транспиляции. Таким образом, можно сказать, что вариант с интерфейсами более легковесный, но все же выбор должен зависеть от задачи, которую мы решаем.

  Важно понимать, что создание класса на основе интерфейса не ведет к реализации этого интерфейса в классе. Тайпскрипт просто проверяет удовлетворяют ли свойства и методы нашего класса свойствам, заявленным в интерфейсе, сам же класс мы пишем вручную. Рассмотрим пример:

  ```typescript
  interface ICalculate {
    sum: (num1: number, num2: number ) => number;
  }

  class Summator implements ICalculate {
    sum(num1, num2) { return num1 + num2; }
    // для параметров будет выведено сообщение: Parameter 'num1'/'num2' implicitly has an 'any' type.
    // потому что TypeScript только проверяет класс на соответствие интерфейсу, но не наследуется от него полноценно

    multiply(num1: number, num2: number) { return num1 * num2; }
    // мы добавили новый метод, но TypeScript не ругается
  }

  let calculator = new Summator();
    // тем не менее, наш код сработает, как если бы он сработал для аргументов с типом any.
    // потому что типы параметров, равно как и все остальное, не были унаследованы классом при реализации интерфейса.
  calculator.sum(2,3) // 5
  ```

  Таким образом, ошибка в реализации интерфейса классом возможна только тогда, когда мы не реализуем одно из свойств, указанных в интерфейсе, или же реализуем его не так, как указано в интерфейсе:

  ```typescript
  interface ICalculate {
    sum: (num1: number, num2: number ) => number;
  }

  class Summator implements ICalculate {
    sum (num1: string, num2: string) { return num1 + num2 };
    // мы изменили типы аргументов на string, то есть неверно реализовали интерфейс.
    // в таком случае TypeScript обратит внимание на нашу ошибку и не скопилируется:
    // Type '(num1: string, num2: string) => string' is not assignable to type '(num1: number, num2: number) => number'.
  }
  ```

  По этой же причине, если мы пишем класс, реализующий интерфейс с опциональными свойствами, нам нужно прописывать все самостоятельно, в противном случае эти свойства не попадут в наш класс:

  ```typescript
  interface ICalculate {
    sum: (num1: number, num2: number ) => number;
    multiply? : (num1: number, num2: number ) => number;
  }

  class Summator implements ICalculate {
    sum (num1: number, num2: number) { return num1 + num2; }
  }

  const calculator = new Summator();
  calculator.sum(2,3) // 5
  calculator.multiply(2,3) // Property 'multiply' does not exist on type 'Summator'.
  ```

  Поскольку в TypeScript для одних и тех же вещей существует несколько разных инструментов, мы можем реализовывать классы с помощью расширения абстрактных классов вместо интерфейсов. Но выбор того, что мы будем реализовывать классами зависит от задачи. Абстрактные классы предоставляют нам модификаторы доступа и конструкторы, в то время как интерфейсы более легковесны и просты.

instructions: |

  С помощью предоставленного интерфейса IPhonebook и типа Entry реализуйте и экспортируйте по умолчанию класс Phonebook, представляющий из себя телефонный справочник, в котором должны быть свойства:

  - `entries`: наша база данных, объект, записи в котором представляют собой имена в качестве ключей и телефоны в качестве значений. Свойство должно быть неизменяемым и доступным только для чтения;
  - `get`: метод, возвращающий телефон по имени;
  - `set`: метод, записывающий имя и телефон в наш справочник.

  примеры:
  ```typescript
  const myNote = new Phonebook();
  myNote.set('help', 911);
  myNote.get('help'); // 911
  ```

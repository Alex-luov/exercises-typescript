---

name: Narrowing
theory: |

  В JavaScript часто встречается код, в котором в одних и тех же переменных, включая переменные функций, могут оказаться значения разных типов. Их обработка строится на основе логических проверок с помощью `typeof` и других подобных механизмов. Ниже пример реализации функции, который конвертирует любое переданное значение в булево с учетом веб-специфики, где пустые строки, объекты и массивы считаются `false`:

  ```typescript
  function isPresence(value: unknown) {
    if (value === null || value === undefined) {
      return false;
    }
    // пустая строка
    if (typeof value === 'string') {
      if (value === '') {
        return false;
      }
    }
    // пустой массив
    if (Array.isArray(value)) {
      if (value.length === 0) {
        return false;
      }
    }
    // пустой объект
    if (value instanceof Object) {
      if (Object.keys(value).length === 0) {
        return false;
      }
    }

    return true;
  }

  isPresence(''); // false
  isPresence({}); // false
  isPresence([]); // false
  isPresence([1, 3]); // true
  isPresence(10); // true
  ```

  В этом коде есть кое-что необычное. Параметр имеет тип `unknown`, но внутри TypeScript позволяет выполнять с этим параметром разные действия, в зависимости от заданных условий. Необычность заключается в том, что проверка типов выполняется статически, до запуска кода, а условия внутри функции — это часть кода, который выполняется в рантайме, то есть во время запуска программы. То есть такой код, должен был бы завершиться с ошибкой, но этого не происходит.

  Секрет здесь в том, что система TypeScript умеет гораздо больше, чем кажется на первый взгляд. Так как подобный код в JavaScript встречается очень часто, то систему типов TypeScript пришлось доработать так, чтобы осталась возможность писать подобный код. В данном случае оказывается то, что TypeScript умеет выполнять часть условных конструкций статически, как проверку совместимости типов, без запуска кода. Затем, уже внутри блока с условием, компилятор считает, что тип значения совпадает с тем, что было в самой проверке. Этот процесс в TypeScript называется Type Narrowing (сужение типа).

  Narrowing работает не только для типа `unknown`. Это универсальный механизм, который работает со всеми возможными типами, например, Union Types:

  ```typescript
  function foo(value: number | string) {
    if (typeof value === 'number') {
      // Работаем как с числом
    }
    if (typeof value === 'string') {
      // Работаем как со строкой
    }
  }
  ```

  Narrowing поддерживает `switch`:

  ```typescript
  function foo(value: number | string) {
    switch (typeof value) {
      case 'number':
        // какая-то логика
        break;
      case 'string':
        // какая-то логика
        break;
    }
  }
  ```

  Перегрузка функций в TypeScript это тоже пример работы Narrowing:

  ```typescript
  function concat(a: number, b: number): string;
  function concat(a: string, b: string): string;

  function concat(a: unknown, b: unknown): string {
    if (typeof a == 'string') {
      return `${a}${b}`;
      //        ^? (parameter) a: string
    } else {
      return `${a.toFixed()}${b.toFixed()}`;
    }
  }
  ```

  Narrowing большая тема с кучей нюансов. Подробнее с особенностями работы этого механизма можно ознакомиться в документации. В любом случае, он будет встречаться в TypeScript достаточно часто и вы так или иначе с ним разберетесь.

instructions: |

  Реализуйте функцию `last()` которая извлекает последний элемент из переданного значения. Значением может быть строка или число. Функция возвращает значение того же типа, которое было передано в качестве параметра:

  ```typescript
  // Передаем в качестве параметра строку
  // Функция возвращает строку
  last('hexlet'); // t

  // Передаем в качестве параметра число
  // Функция возвращает число
  last(12345); // 5
  ```

tips:
  - |
    [Официальная документация](https://www.typescriptlang.org/docs/handbook/2/narrowing.html)
